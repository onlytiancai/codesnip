这一页 PPT 的主题只有一个：
**“理论上能解，不代表计算机算得好。”**

正规方程在数学上很优雅，但在真实计算里，QR 分解才是更可靠的工具。这一页就是在解释**为什么工程上要这么做**。

---

先从最上面的结论说起：
**我们不直接解 $X^T X \beta = X^T $**，而是换一条更稳的路。

---

先看什么是 **QR 分解**。

任何一个“列线性无关”的矩阵 $X$，都可以写成：
$
X = QR
$

这里面两个部分的角色非常清楚：

* $Q$：列向量彼此正交、长度为 1
  几何意义是：**只负责方向，不会拉伸或缩放空间**

* $R$：上三角矩阵
  负责把坐标“揉”在一起，方便解方程

你可以把 QR 分解理解成：

> **先把坐标系转正（Q），再在新坐标系里解一个简单问题（R）。**

---

接下来是关键的一步：
**最小二乘问题是怎么用 QR 解的？**

我们原来的目标是：
$$
\min_\beta |y - X\beta|
$$

把 $X = QR$ 代进去：
$$
|y - QR\beta|
$$

现在用到一个非常重要的性质：

> **正交矩阵不会改变向量长度。**

也就是说：
$$
|y - QR\beta|
= |Q^T y - R\beta|
$$

这一步非常关键，它说明我们只是**换了坐标系，没有改变几何距离**。

---

于是问题变成了：

$$
\min_\beta |Q^T y - R\beta|
$$

由于 (R) 是上三角矩阵，最优解满足：
$$
R\beta = Q^T y
$$

这就是 PPT 里写的那一行。

---

为什么这个方程这么好解？

因为 $R$ 是上三角矩阵，长得像这样：
$$
\begin{pmatrix}

* & * & * \\
  0 & * & * \\
  0 & 0 & *
  \end{pmatrix}
  $$

你可以从最后一个未知数开始，一步一步往回算，这个过程叫：

> **回代法（Back-substitution）**

计算量小、稳定性好，非常适合计算机。

---

现在来到整页最重要的问题：
**为什么 QR 比正规方程稳定？**

---

关键在于一个词：**条件数（Condition Number）**。

* 条件数衡量的是：
  **输入的微小误差，会被放大多少倍传到输出**

* 条件数越大，数值越不稳定

---

如果你走正规方程这条路：
$$
X^T X \beta = X^T y
$$

问题来了：

$$
\kappa(X^T X) = \kappa(X)^2
$$

也就是说：

* 原本已经有点“扁”的碗
* 被你又压了一次
* 数值误差被平方放大

这在浮点计算中是非常危险的。

---

而 QR 分解的优势在于：

* $Q$ 是正交矩阵
  → 条件数是 1
  → **不放大误差**

* 整个过程的数值稳定性，基本保持在：
  $$
  \kappa(X)
  $$
  这个量级

这就是 PPT 里那句：

> “QR 方法保持了 $κ(X)$ 的量级”

---

最后一点是**工程实践的经验总结**。

理论上：

* Gram–Schmidt 可以算 QR
* 但它对浮点误差很敏感

工程上：

* **Householder 变换**更稳定
* 能一步步“反射”向量
* 几乎不会积累误差

所以你在 LAPACK、NumPy、MATLAB 里看到的 QR，
基本都是 **Householder QR**。

---

最后，用一句话收尾这页 PPT：

正规方程适合理解问题结构；
QR 分解适合真正去算。
前者漂亮，后者可靠。
在计算机世界里，**稳定性比公式好看更重要**。

---

> 介绍这里的$\mathrm{cond}(X)$ 和   $ \kappa(X)$

这两个符号其实指的是**同一件事**，只是写法不同：

$$
\mathrm{cond}(X) \equiv \kappa(X)
$$

它们都叫 **矩阵的条件数（condition number）**。这一页提到它，是因为条件数几乎是**数值稳定性**的核心指标。

下面我用“直觉 → 数学定义 → 几何解释 → 为什么在最小二乘里重要”这条线来讲。

---

先说最直观的一句话理解：

> **条件数衡量的是：输入里一个很小的误差，会被结果放大多少倍。**

如果条件数很大，哪怕数据只抖了一点点，算出来的解也可能抖得非常厉害。

---

接下来是最常用的数学定义（不纠结推导）：

在默认使用的 **2-范数** 下，

$$
\kappa(X) = |X|_2 |X^{-1}|_2
$$

如果 $X$ 不可逆，就认为：
$$
\kappa(X) = \infty
$$

也就是说：

* 能不能稳稳地“反过来算”
* 完全由这个数控制

---

这个定义看起来有点抽象，但在 2-范数下，有一个**极其重要、非常直观的等价形式**：

$$
\boxed{
\kappa(X) = \frac{\sigma_{\max}}{\sigma_{\min}}
}
$$

这里：

* $\sigma_{\max}$：最大奇异值
* $\sigma_{\min}$：最小奇异值

你可以先把“奇异值”理解成：

> **矩阵在不同方向上，把向量拉伸的倍数。**

---

现在给你一个非常关键的几何图像。

假设你拿一个单位圆（或单位球），用矩阵 $X$ 去作用它：

* 如果变成一个**接近圆的椭圆**
  → 所有方向拉伸得差不多
  → $\kappa(X)$ 接近 1
  → 非常稳定

* 如果变成一个**极扁的椭圆**
  → 有的方向被拉得很长
  → 有的方向几乎被压扁
  → $\sigma_{\min}$ 很小
  → $\kappa(X)$ 非常大

这说明：

> **某些方向的信息几乎被“压没了”。**

---

这在最小二乘中意味着什么？

在回归里：

* 列空间方向 = 特征方向
* 如果某些特征几乎线性相关
* 就会出现 $\sigma_{\min} \approx 0$

结果是：

* 解对噪声极其敏感
* 系数会剧烈波动
* 数值不稳定

这就是所谓的 **病态问题（ill-conditioned）**。

---

现在你就能理解 PPT 里那句关键话了：

> 计算 $X^T X$ 会平方条件数

因为：
$$
\kappa(X^T X) = \kappa(X)^2
$$

几何上看就是：

* 本来已经很扁的椭圆
* 再被压一次
* 最短方向更接近 0

浮点误差被指数级放大。

---

最后，用几条“工程直觉”帮你定型：

* $\kappa(X) \approx 1$：
  极其稳定，几乎完美

* $\kappa(X) \sim 10^2 \sim 10^4$：
  一般还能接受

* $\kappa(X) \gg 10^8$：
  非常危险，数值结果不可信

---

一句话总结：

$$
\mathrm{cond}(X) \text{或} \kappa(X)
$$

衡量的是：
**矩阵把几何形状“拉扯得有多不均匀”，也就是解对误差有多敏感。**

也正因为这个原因，工程上宁愿多做一次 QR 分解，
也不愿意直接去算 $X^T X$。
