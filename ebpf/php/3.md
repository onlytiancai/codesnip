php 进程本身有没有调试接口或可观测接口，可以直接把当前正在执行的代码，函数等信息打印出来或写入某个文件，比如给个信号或者发个信息

有的，而且**不止一种层级**。不过要先给你一个总体判断：
**PHP 并没有一个“官方、统一、给进程发个信号就自动 dump 当前执行代码”的接口**，但在不同层面上，确实存在**可用、稳定、被大量运维/内核调试实践验证的可观测手段**。只是它们分散在：Zend Engine、SAPI、扩展、以及外部工具层。

我按“从最像你想要的 → 到最底层”的顺序讲。

---

先说你最关心的那个问题：

**能不能给 PHP 进程发个信号，让它把当前执行的函数/文件/行号写出来？**

👉 **原生 PHP：不能直接做到这一点。**

原因很现实：

* PHP 的信号处理非常保守
* Zend VM 执行期间不能随便做复杂操作（非 async-signal-safe）
* 官方避免提供这种会破坏执行一致性的接口

但下面这些方案，可以“几乎达到同样效果”。

---

### 一、php-fpm 自带的“慢但稳定”的可观测接口（强烈推荐）

这是**生产环境最常用**的方式。

#### 1）FPM slowlog（最接近你要的）

当一个请求执行超过阈值时，PHP-FPM **会自动 dump 当前执行栈**。

配置示例：

```
request_slowlog_timeout = 3s
slowlog = /var/log/php-fpm/slow.log
```

slowlog 内容包括：

* 当前执行的 PHP 文件
* 行号
* 函数调用栈
* include / require 路径

这背后做的事情正是：

* 遍历 `zend_execute_data`
* 打印当前执行上下文

优点：

* 官方支持
* 非侵入
* 生产可用

缺点：

* 只能在“慢请求”触发
* 不是你随时手动触发的

如果你的问题是「**这个 PHP worker 卡在哪了？**」，slowlog 是第一选择。

---

#### 2）php-fpm status / ping

不是执行级别，但有帮助：

```
pm.status_path = /status
ping.path = /ping
```

你能看到：

* 哪些 worker 在忙
* 请求运行了多久

结合 slowlog，定位非常快。

---

### 二、PHP 扩展层：可以“发信号 dump 执行栈”（但要自己做）

如果你愿意写 C 扩展，这一层**是可以实现你说的“给进程发信号，然后 dump 当前执行代码”的**。

#### 可行的思路（核心要点）

* 注册信号处理器（如 SIGUSR1）
* 信号 handler 里**只做一件事**：设置一个全局 flag
* 在 VM 执行安全点（如 `zend_execute_ex` hook）里检测 flag
* 通过 Zend API dump：

  * 当前函数
  * 文件
  * 行号
  * 调用栈
* 写入文件或 syslog

关键点：

* **绝对不能在 signal handler 里直接操作 Zend**
* 必须延迟到 VM 执行流程中

很多调试扩展（包括 xdebug 的部分设计）都是这个模式。

---

### 三、现成的“准官方”方案：Xdebug / phpdbg

#### 1）Xdebug（不是给信号用，但能力最强）

Xdebug 能做到：

* `xdebug_get_function_stack()`
* `xdebug_get_tracefile_name()`
* 函数进入/退出 tracing
* profiler

但问题是：

* 生产环境开销大
* 不适合临时 attach 到正在跑的进程
* 不能靠信号触发

---

#### 2）phpdbg（CLI 调试器）

`phpdbg` 是 Zend 官方调试器，但：

* 只能用于 CLI
* 不能 attach 到已有 PHP 进程
* 对 php-fpm 无能为力

所以它不适合你的使用场景。

---

### 四、内核 / 用户态外部观测（你已经在用的路线）

你现在用的 **bpftrace + uprobe**，本质上是：

> 在“不让 PHP 知道你在观察”的情况下，读取它的执行状态

这其实是**目前唯一能做到：**

* 不改 PHP
* 不装扩展
* 不重启进程
* 随时 attach
* 精确到行号 / 函数

的方案。

Zend Engine 本身并没有给你一个“dump now”接口，所以 eBPF 反而成了事实上的“运行中调试接口”。

---

### 五、有没有隐藏 / 内部接口？（实话）

结论很明确：

* ❌ 没有官方的 `kill -USR1 php → dump stack`
* ❌ 没有 SAPI 级的调试信号
* ✔️ 有内部函数（你列的那些 `zend_get_executed_*`）
* ✔️ 有完整执行栈数据结构（`zend_execute_data`）

但这些都**没有暴露为安全的运行时 API**。

---

### 六、现实世界的推荐组合

如果你是在生产环境排障，我给你一个“工程上最靠谱”的组合：

1）**优先启用 php-fpm slowlog**
→ 解决 80%“卡在哪”的问题

2）**bpftrace / eBPF**
→ 用于：

* 临时 attach
* 精确定位
* 不可重现问题

3）**必要时写一个最小调试扩展**
→ 专门用于信号触发 dump（仅在特殊环境）

---

### 一句话总结

* PHP **没有**提供“给进程一个信号就打印当前执行代码”的官方接口
* 这是有意设计的限制，而不是缺失
* **php-fpm slowlog + eBPF** 是目前事实上的“可观测标准方案”
* 你已经选了**最硬核、也是最自由的一条路**

如果你愿意，我可以直接帮你设计一个**SIGUSR1 + Zend hook 的最小扩展方案**，或者写一个**实战可用的 bpftrace 脚本**，专门做“即时 dump 当前 PHP 执行点”。
