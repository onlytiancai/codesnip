# bpftrace -l 'uprobe:/usr/bin/php8.3:*zend*' | grep execute
uprobe:/usr/bin/php8.3:zend_execute
uprobe:/usr/bin/php8.3:zend_execute_scripts
uprobe:/usr/bin/php8.3:zend_get_executed_filename
uprobe:/usr/bin/php8.3:zend_get_executed_filename_ex
uprobe:/usr/bin/php8.3:zend_get_executed_lineno
uprobe:/usr/bin/php8.3:zend_get_executed_scope

分别解释下这几个函数的作用和关系，包括它们的参数和返回值，我如何查看某个PHP进程正在做什么呢？

这些都是 **Zend Engine（PHP 内核）里和“执行中脚本上下文”相关的核心符号**。它们之间的关系，其实围绕着一个中心问题：**PHP 当前正在执行什么代码、在哪里执行、以什么方式执行**。我按“执行流程 → 上下文查询 → 你如何用 bpftrace 观察进程行为”这个顺序来讲，会比较清晰。

---

先从最核心的两个说起。

**1）zend_execute**

这是 Zend Engine 的**核心执行函数之一**。
它负责执行一条已经编译好的 opcode 数组（op_array），也就是 PHP 代码在编译阶段生成的中间表示。

简化理解：

* PHP 源码 → 编译成 opcodes（op_array）
* `zend_execute()` → 真正逐条执行这些 opcodes

典型特征：

* 调用频率极高（几乎所有 PHP 代码都会经过它）
* 在函数调用、方法调用、include/require 之后都会触发

大致签名（简化）：

```
void zend_execute(zend_execute_data *execute_data)
```

参数说明：

* `execute_data`

  * 当前执行栈帧
  * 包含：

    * 正在执行的函数 / 方法
    * op_array
    * 变量表
    * 调用链信息

返回值：

* `void`
* 执行结果通过 `execute_data` 和 VM 状态体现

---

**2）zend_execute_scripts**

这是一个**更高层的执行入口**，主要用于执行“脚本级别”的代码。

什么时候用它？

* PHP 启动时执行入口脚本（如 index.php）
* include / require 一个文件
* CLI 模式下执行脚本

可以理解为：

> `zend_execute_scripts` → 准备环境 → 编译脚本 → 调用 `zend_execute`

典型签名（简化）：

```
int zend_execute_scripts(
    int type,
    zval *retval,
    int file_count,
    ...
)
```

关键参数含义：

* `type`

  * 执行模式（如 `ZEND_REQUIRE`、`ZEND_INCLUDE`）
* `retval`

  * 脚本返回值（很少用）
* `file_count`

  * 要执行的脚本数量
* 后面的可变参数

  * 每个脚本的文件名（zend_file_handle）

返回值：

* `SUCCESS` 或 `FAILURE`

关系总结一句话：

> `zend_execute_scripts` 是“执行脚本的入口”，
> `zend_execute` 是“执行 opcode 的引擎核心”。

---

接下来这几个，是**“执行中上下文查询函数”**，它们不负责执行，而是“告诉你正在执行什么”。

---

**3）zend_get_executed_filename**

返回**当前正在执行的 PHP 文件名**。

简化签名：

```
const char *zend_get_executed_filename(void)
```

返回值：

* `const char *`
* 指向当前执行文件的绝对路径（或相对路径）
* 如果在 eval、内部函数等特殊场景，可能返回类似：

  * `eval()'d code`
  * `Command line code`

用途：

* 错误处理
* 调试
* profiler / tracer

---

**4）zend_get_executed_filename_ex**

这是上一个函数的“增强版”。

签名（简化）：

```
const char *zend_get_executed_filename_ex(uint32_t *type)
```

多了一个输出参数：

* `type`

  * 标识代码来源
  * 例如：

    * 普通文件
    * eval
    * 内部代码

返回值：

* 文件名字符串（同上）

你用 bpftrace 的时候，这个函数比 `zend_get_executed_filename` 更有价值，因为它能帮你区分“真实文件”还是“动态代码”。

---

**5）zend_get_executed_lineno**

返回**当前正在执行的行号**。

签名：

```
uint32_t zend_get_executed_lineno(void)
```

返回值：

* 行号（从 1 开始）
* 如果在某些内部执行阶段，可能返回 0

通常和 filename 一起用：

> filename + lineno = 当前 PHP 正在跑哪一行

---

**6）zend_get_executed_scope**

返回**当前执行作用域（类作用域）**。

签名（简化）：

```
zend_class_entry *zend_get_executed_scope(void)
```

返回值：

* `zend_class_entry *`

  * 如果在类方法中 → 当前类
  * 如果在全局函数或脚本 → `NULL`

用途：

* 判断代码是否在某个类方法内
* 获取类名、父类、接口等元信息

---

到这里，可以把它们的关系总结成一张逻辑图（文字版）：

* `zend_execute_scripts`

  * 执行脚本 / 文件
  * ↓
* `zend_execute`

  * 执行 opcode（函数、方法、脚本）
  * 执行过程中：

    * `zend_get_executed_filename(_ex)`
    * `zend_get_executed_lineno`
    * `zend_get_executed_scope`
      → 用来“查询当前正在执行什么”

---

**重点问题：我如何查看某个 PHP 进程正在做什么？**

你已经走在**正确的路上**：`bpftrace + uprobe`。

几个实用思路，从简单到深入。

---

**1）查看 PHP 进程当前在执行哪个文件和行号**

思路：

* 在 `zend_execute` 上挂 uprobe
* 在 probe 里调用：

  * `zend_get_executed_filename`
  * `zend_get_executed_lineno`

概念示例（不是完整脚本）：

```
uprobe:/usr/bin/php8.3:zend_execute
{
    printf("%s:%d\n",
        str(zend_get_executed_filename()),
        zend_get_executed_lineno());
}
```

这能告诉你：

* 某个 PHP 进程正在跑哪个文件的哪一行
* 特别适合定位：

  * 卡住的请求
  * CPU 飙高的 PHP-FPM worker

---

**2）只观察某个 PHP 进程**

你通常会加条件：

* `pid == XXX`
* 或通过 php-fpm worker PID 过滤

这样不会被其他 PHP 进程淹没。

---

**3）区分 eval / include / 普通脚本**

用：

* `zend_get_executed_filename_ex`

你可以判断：

* 是否大量 eval（安全 / 性能问题）
* 是否频繁 include 某个文件

---

**4）查看正在执行哪个类 / 方法**

结合：

* `zend_execute`
* `zend_get_executed_scope`
* 从 `execute_data` 里取函数名（更高级）

这一步通常需要：

* 解析 `zend_execute_data`
* 偏内核级，适合你已经熟悉 Zend Engine 结构的情况下做

---

**一句经验总结**

* `zend_execute`：最重要的执行探针
* `zend_execute_scripts`：看“脚本级入口”
* `zend_get_executed_*`：用来回答“PHP 正在做什么”
* bpftrace 的价值在于：

  * **不改代码**
  * **不重启 PHP**
  * **实时观测生产进程**

如果你愿意，下一步我可以直接帮你写一个**可用的 bpftrace 脚本**，专门用来定位“某个 PHP-FPM worker 卡在什么代码上”。
