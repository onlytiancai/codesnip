```
bpftrace -e'
struct zend_class_entry_min {
    u64 type;
    void *name;
};
uretprobe:/usr/bin/php8.3:zend_get_executed_scope
/ pid == 1444876 /
{
    if (retval == 0) {
        printf("retval == 0");
        return;
    }

    $ce = (struct zend_class_entry_min *)retval;
    // printf("$ce ===:%r\n", buf($ce, 64));
    if ($ce->name != 0) {

        $zs = (uint64)$ce->name;
        // printf("raw: %r\n", buf($zs, 64));

        $len = *(uint64*)($zs + 0x10);
        $class = str($zs + 0x18, $len);

        printf("zend_string: len=%d, val=%s\n", $len, $class);

    }
}
'
```
修改这段bpftrace代码，让它执行5秒，统计每个class的数量，可考虑采样，可考虑用map，还有intevel

---

下面给你一个**可直接用的 bpftrace 脚本思路**，满足这几个目标：

* 运行 **5 秒自动退出**
* **统计每个 class 出现的次数**
* 使用 **map**
* 支持 **采样（可选）**
* 使用 **interval** 在结束时统一输出

我会先给一个“稳定版”（不采样），再给一个“采样版”，你可以按需要选。

---

### 一、核心思路说明（简要）

1. 用 `@classes[classname] = count()` 统计每个类名
2. 用 `interval:s:5` 在 5 秒时输出并 `exit()`
3. 在 `uretprobe` 中只做采集，不 `printf`，避免性能问题
4. `zend_string` 读取方式保持你现在用的偏移

---

### 二、不采样版本（最准确）

```bpftrace
struct zend_class_entry_min {
    u64 type;
    void *name;
};

uretprobe:/usr/bin/php8.3:zend_get_executed_scope
/ pid == 1444876 /
{
    if (retval == 0) {
        return;
    }

    $ce = (struct zend_class_entry_min *)retval;
    if ($ce->name == 0) {
        return;
    }

    $zs = (uint64)$ce->name;
    $len = *(uint64*)($zs + 0x10);

    // 简单防御，避免异常长度
    if ($len <= 0 || $len > 256) {
        return;
    }

    $class = str($zs + 0x18, $len);
    @classes[$class] = count();
}

interval:s:5
{
    printf("\n=== Class statistics (5s) ===\n");
    print(@classes);
    clear(@classes);
    exit();
}
```

运行方式：

```bash
bpftrace script.bt
```

特点：

* 统计完整、准确
* 对 `zend_get_executed_scope` 调用频率高时开销略大

---

### 三、采样版本（推荐线上用）

如果调用非常频繁，建议加采样，例如 **1/10**：

```bpftrace
struct zend_class_entry_min {
    u64 type;
    void *name;
};

uretprobe:/usr/bin/php8.3:zend_get_executed_scope
/ pid == 1444876 && (rand() % 10 == 0) /
{
    if (retval == 0) {
        return;
    }

    $ce = (struct zend_class_entry_min *)retval;
    if ($ce->name == 0) {
        return;
    }

    $zs = (uint64)$ce->name;
    $len = *(uint64*)($zs + 0x10);

    if ($len <= 0 || $len > 256) {
        return;
    }

    $class = str($zs + 0x18, $len);
    @classes[$class] = count();
}

interval:s:5
{
    printf("\n=== Sampled class statistics (5s, 1/10) ===\n");
    print(@classes);
    clear(@classes);
    exit();
}
```

说明：

* 数量是**采样后的相对值**
* 类分布仍然非常有参考价值
* 性能压力显著降低

---

### 四、可选增强（如果你想再进阶）

1. **只看 Top N**

```bpftrace
print(@classes, 20);
```

2. **按 PID + class 统计**

```bpftrace
@classes[pid, $class] = count();
```

3. **按 namespace / request 粒度**
   可以再加 `tid` 或 request id（如果你能拿到）

---

如果你愿意，我也可以帮你：

* 校验 **zend_string 偏移是否完全适配 PHP 8.3**
* 改成 **ustack + class 关联**
* 做成 **持续运行、每 5 秒滚动输出**
* 或直接帮你定位 **最热 class / 最重路径**

你可以直接说你现在的目标是“性能分析 / 行为统计 / 泄漏排查”。
