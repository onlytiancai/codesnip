# 回测

1. 期货高频趋势跟踪策略（1 分钟级别）

数据输入：60 分钟历史 1 分钟 K 线（开盘价、收盘价、成交量、持仓量）+ 实时订单簿（买一卖一价差、深度）。

模型设计：4 层因果 Transformer 编码器，输入序列长度 60，输出未来 5 分钟收益率预测。

信号规则：当预测收益率 > 0.1% 且多头注意力权重（对上涨时段的关注度）>0.6 时做多，反之做空，持仓不超过 15 分钟。

回测效果：在螺纹钢期货上，2023 年样本内年化收益 28%，最大回撤 8%，夏普比率 2.1，胜率 58%。

写代码实现这个策略

---

好的，根据您提供的期货高频趋势跟踪策略描述，我将为您构建一个基于 Python 和 PyTorch 的代码实现框架。

### **重要声明**

  * **概念验证框架：** 以下代码是一个完整的**实现框架和概念验证**，而非一个可直接用于实盘交易的系统。它旨在清晰地展示策略的各个组成部分，包括数据处理、模型构建、信号生成和回测逻辑。
  * **数据缺失：** 我无法访问真实的螺纹钢期货 2023 年 1 分钟 K 线和订单簿数据。因此，代码将使用**随机生成的模拟数据**。您需要将数据加载部分替换为您自己的真实数据才能进行有效的训练和回测。
  * **模型未训练：** 由于没有真实数据，代码中的 Transformer 模型将使用**随机初始化的权重**，并直接进入评估模式。一个有效的策略需要在大规模数据集上对模型进行严格的训练和验证。
  * **环境依赖：** 运行此代码需要安装 Python，并安装 `pandas`, `numpy`, 和 `torch` 库。您可以使用 `pip install pandas numpy torch` 命令进行安装。
  * **风险提示：** 期货交易涉及高风险，历史回测结果不代表未来收益。高频策略对交易成本、滑点和网络延迟极为敏感，这些因素在模拟回测中难以完全复现。

-----

### **策略实现代码**

以下代码实现了您描述的策略的完整逻辑。

```python


```

### **代码结构解析**

1.  **数据模拟与准备 (`generate_mock_data`, `create_features`)**

      * `generate_mock_data`: 创建一个符合格式的 `pandas.DataFrame`，包含了K线和订单簿的关键信息。**您需要用真实数据加载替换此函数。**
      * `create_features`: 计算模型所需的特征。例如，将绝对价格和成交量转化为变化率，这有助于模型学习。同时，它计算了`is_uptime`（收盘价\>开盘价），这是后面计算“多头注意力权重”的关键。它还创建了`target_return`用于模型训练（虽然本代码未进行训练）。

2.  **模型设计 (`CausalTransformerEncoder`)**

      * 这是一个继承自 `torch.nn.Module` 的标准 PyTorch 模型。
      * **`__init__`**: 定义了模型的各个组件：输入投影层、位置编码、4层Transformer编码器和输出层。
      * **Causal Mask**: `generate_causal_mask` 创建了一个上三角矩阵掩码。这在处理时间序列时至关重要，它能防止模型在预测时间点 `t` 时“偷看”到 `t+1`, `t+2`, ... 的信息。
      * **`forward`**: 定义了数据在模型中的流动路径。一个关键的修改是为了获取注意力权重。标准的 `nn.TransformerEncoder` 不会直接返回它们，但在 `nn.MultiheadAttention` 层面可以设置 `need_weights=True`。这里的代码模拟了从最后一层捕获这些权重的过程。

3.  **策略与回测 (`Backtester`)**

      * **`__init__`**: 初始化回测器，接收模型、数据和策略参数（如持仓周期）。
      * **`run`**: 这是回测的核心循环。它逐分钟遍历数据：
          * 首先检查现有仓位是否需要根据“持仓不超过15分钟”的规则平仓。
          * 如果没有持仓，它会准备最近60分钟的数据作为模型输入。
          * 调用模型获得 `predicted_return` 和 `attention_weights`。
          * **信号逻辑实现**:
              * 它从 `(batch, heads, seq, seq)` 形状的注意力权重中，提取出最后一个时间步对过去60个时间步的关注度，并跨头取平均。
              * `bullish_attention_score` 的计算是策略的核心：将上一步得到的注意力向量与`is_uptime`序列（标记了哪些分钟是上涨的）进行点乘求和，从而得到模型对过去上涨时段的总体关注度。
              * 最后，根据预测收益率和这个注意力分数，执行做多或做空的判断。
      * **`open_position` / `close_position`**: 管理仓位状态，记录交易日志。
      * **`calculate_performance`**: 在回测结束后，基于交易日志计算胜率、夏普比率等性能指标（此处为简化计算）。

### **如何使用和改进**

1.  **接入真实数据**:

      * 修改 `generate_mock_data` 函数，使其从您的数据源（如 CSV, HDF5, 数据库）加载数据。
      * 确保数据的时间戳是连续的1分钟数据，并包含所有必需的列。

2.  **模型训练**:

      * 您需要将数据集分割为训练集、验证集和测试集。
      * 编写一个标准的 PyTorch 训练循环：
          * 定义损失函数（例如，对于回归任务，使用 `nn.MSELoss`）。
          * 选择一个优化器（例如，`torch.optim.Adam`）。
          * 在训练集上迭代，计算损失，反向传播，并更新模型权重。
          * 在验证集上监控模型性能，以防止过拟合。
      * 训练完成后，保存模型权重（`torch.save(model.state_dict(), 'model_weights.pth')`），并在回测前加载它们（`model.load_state_dict(torch.load('model_weights.pth'))`）。

3.  **完善回测引擎**:

      * **交易成本**: 在计算盈亏时扣除手续费和滑点。高频策略对此非常敏感。
      * **资金管理**: 引入固定的交易规模或基于权益的动态规模调整。
      * **性能指标**: 计算更精确的最大回撤（基于权益曲线，而非单笔亏损）、Calmar比率等更专业的指标。

这个代码框架为您提供了一个坚实的起点，您可以基于它来构建、训练和验证您所描述的复杂高频交易策略。

---

# 训练代码

写出模型训练代码，训练和测试用的数据提前随机生成到一个csv里

好的，遵照您的要求，我们来完成模型训练的部分。

下面的代码将分为几个清晰的步骤：

1. **数据生成与保存**：首先，我们会生成一份包含一年模拟交易日（约6万分钟）的mock\_data.csv文件。这确保了我们的训练和测试都基于同一份静态数据。  
2. **模型训练脚本**：然后，我们将编写一个完整的训练脚本。该脚本会：  
   * 从mock\_data.csv加载数据。  
   * 将数据划分为训练集和验证集。  
   * 使用标准的PyTorch训练流程（Dataset, DataLoader, 损失函数, 优化器）来训练之前定义的Transformer模型。  
   * 在每个周期（epoch）结束后，在验证集上评估模型性能，以监控训练过程。  
   * 训练结束后，将性能最好的模型权重保存到文件 transformer\_hft\_model.pth 中。

这个保存下来的模型文件，之后便可以被回测脚本加载，用于执行更接近实战的策略评估。

---

### **模型训练完整代码**

这是一个独立的、可直接运行的Python脚本。请确保您已安装 pandas, numpy, 和 torch。

期货高频策略模型训练  
Jul 31, 11:48 AM  
Open

### **如何运行和后续步骤**

1. **运行脚本**：将以上代码保存为 train.py 文件，然后在您的终端中运行 python train.py。  
   * **首次运行**：它会生成 mock\_data.csv 文件，然后开始训练模型，这个过程可能需要几分钟，具体取决于您的计算机性能。您会看到每个周期的训练和验证损失。  
   * **后续运行**：脚本会检测到 mock\_data.csv 已存在，直接跳过数据生成，开始训练。  
2. **训练产物**：训练完成后，您的文件夹中会多出两个文件：  
   * mock\_data.csv: 包含所有模拟数据的源文件。  
   * transformer\_hft\_model.pth: 保存了训练过程中验证损失最低的模型权重。  
3. 下一步：修改回测脚本：  
   现在，您需要修改上一轮提供的回测脚本，让它加载我们刚刚训练好的模型，而不是使用随机初始化的模型。您只需在回测脚本的 main 部分做如下修改：  
   Python  
   \# 在回测脚本的 main 函数中

   \# ... (省略其他代码) ...

   \# 2\. 初始化模型  
   print("\\n从 'transformer\_hft\_model.pth' 加载已训练的模型...")  
   model \= CausalTransformerEncoder(  
       num\_features=NUM\_FEATURES,  
       model\_dim=MODEL\_DIM,  
       num\_heads=NUM\_HEADS,  
       num\_layers=NUM\_LAYERS,  
       seq\_len=SEQ\_LEN  
   )  
   \# 加载保存的权重  
   model.load\_state\_dict(torch.load('transformer\_hft\_model.pth'))  
   model.eval() \# 确保设置为评估模式

   \# 3\. 运行回测  
   \# ... (后续代码不变) ...

通过这个流程，您就完成了一个从数据生成、模型训练到模型保存的完整机器学习工作流。接下来使用这个经过训练的模型进行回测，其结果会比使用随机模型更有意义。

---
合并后的代码

    python run_strategy.py --mode train
    python run_strategy.py --mode train --epochs 20 --lr 0.0005
    python run_strategy.py --mode backtest

