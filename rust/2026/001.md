ä¸‹é¢ç»™ä½ ä¸€ä¸ª**å®Œæ•´ã€å¯è¿è¡Œã€åâ€œæ­£å®— Rust é£æ ¼â€çš„å•é“¾è¡¨å®ç°**ï¼Œå¹¶ä¸”**å¸¦å•å…ƒæµ‹è¯•**ã€‚è¿™æ˜¯é¢è¯•ã€å­¦ä¹ æ‰€æœ‰æƒ/Box/Option æ—¶éå¸¸ç»å…¸çš„ä¸€ç‰ˆã€‚

è¿™ä¸ªå®ç°æ”¯æŒï¼š

* åˆ›å»ºç©ºé“¾è¡¨
* å¤´æ’ï¼ˆpushï¼‰
* å¤´åˆ ï¼ˆpopï¼‰
* æŸ¥çœ‹å¤´å…ƒç´ ï¼ˆpeekï¼‰
* ä¸å¯å˜/å¯å˜è¿­ä»£å™¨
* è‡ªåŠ¨å†…å­˜é‡Šæ”¾
* å•å…ƒæµ‹è¯•

å…ˆçœ‹ä»£ç ï¼Œå†è§£é‡Šå…³é”®ç‚¹ã€‚

```rust
// å•é“¾è¡¨å®šä¹‰
pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    // åˆ›å»ºç©ºé“¾è¡¨
    pub fn new() -> Self {
        List { head: None }
    }

    // å¤´æ’
    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    // å¤´åˆ 
    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }

    // æŸ¥çœ‹å¤´å…ƒç´ ï¼ˆä¸å¯å˜ï¼‰
    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|node| &node.elem)
    }

    // æŸ¥çœ‹å¤´å…ƒç´ ï¼ˆå¯å˜ï¼‰
    pub fn peek_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|node| &mut node.elem)
    }
}

// ä¸å¯å˜è¿­ä»£å™¨
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<T> List<T> {
    pub fn iter(&self) -> Iter<'_, T> {
        Iter {
            next: self.head.as_deref(),
        }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}

// å¯å˜è¿­ä»£å™¨
pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<T> List<T> {
    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        IterMut {
            next: self.head.as_deref_mut(),
        }
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &mut node.elem
        })
    }
}

// æµ‹è¯•
#[cfg(test)]
mod tests {
    use super::List;

    #[test]
    fn basic_push_pop() {
        let mut list = List::new();

        assert_eq!(list.pop(), None);

        list.push(1);
        list.push(2);
        list.push(3);

        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        list.push(4);
        list.push(5);

        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);

        list.push(1);
        list.push(2);

        assert_eq!(list.peek(), Some(&2));

        list.peek_mut().map(|x| *x = 42);
        assert_eq!(list.peek(), Some(&42));
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1);
        list.push(2);
        list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&3));
        assert_eq!(iter.next(), Some(&2));
        assert_eq!(iter.next(), Some(&1));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1);
        list.push(2);

        for x in list.iter_mut() {
            *x *= 10;
        }

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&20));
        assert_eq!(iter.next(), Some(&10));
        assert_eq!(iter.next(), None);
    }
}
```

ä½ å¯ä»¥ç›´æ¥ï¼š

```bash
rustc --test list.rs
./list
```

æˆ–è€…æ”¾è¿› `cargo new` é¡¹ç›®é‡Œè·‘ `cargo test`ã€‚

å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥å¸®ä½ ï¼š

* æ”¹æˆ **å°¾æ’ O(1)** çš„é“¾è¡¨
* å¯¹æ¯” `Rc<RefCell<T>>` ç‰ˆæœ¬
* æ‰‹å†™ `Drop`ï¼Œè§£é‡Šä¸ºä»€ä¹ˆè¦ `take()`
* æˆ–æŠŠå®ƒå’Œ C/C++ çš„é“¾è¡¨é€è¡Œå¯¹ç…§è®²æ¸…æ¥š

---

å¥½ï¼Œè¿™é‡Œæˆ‘ä¼š**å®Œå…¨ç«™åœ¨ Rust å°ç™½è§†è§’**ï¼Œä¸è·³æ­¥ã€ä¸å·æ¦‚å¿µï¼Œ**æŒ‰â€œå‡½æ•° â†’ è¡Œ â†’ å…³é”®æŠ€æœ¯ç‚¹â€**æ¥è®²ã€‚
æˆ‘ä¸ä¼šè®²æµ‹è¯•éƒ¨åˆ†ï¼Œåªè®²â€œé“¾è¡¨æœ¬ä½“ + è¿­ä»£å™¨â€ï¼Œè€Œä¸”ä¼šåå¤å¼ºè°ƒ **Rust ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆå†™**ã€‚

---

å…ˆæŠŠæ•´ä½“ç»“æ„æ”¾åœ¨è„‘å­é‡Œï¼š

* è¿™æ˜¯ä¸€ä¸ª **å•é“¾è¡¨**
* æ¯ä¸ªèŠ‚ç‚¹åœ¨å †ä¸Šï¼ˆ`Box`ï¼‰
* èŠ‚ç‚¹ä¹‹é—´ç”¨ `Option` ä¸²èµ·æ¥
* Rust ç”¨ **æ‰€æœ‰æƒ + å€Ÿç”¨** ä¿è¯å†…å­˜å®‰å…¨

---

## ä¸€ã€æ•°æ®ç»“æ„å®šä¹‰éƒ¨åˆ†

### 1ï¸âƒ£ `List<T>`

```rust
pub struct List<T> {
    head: Link<T>,
}
```

è§£é‡Šï¼š

* `List<T>`ï¼šä¸€ä¸ª**æ³›å‹ç»“æ„ä½“**

  * `T` è¡¨ç¤ºé“¾è¡¨é‡Œå­˜ä»€ä¹ˆç±»å‹ï¼Œæ¯”å¦‚ `i32`ã€`String`
* `head`ï¼šé“¾è¡¨çš„å¤´æŒ‡é’ˆ
* Rust æ²¡æœ‰ `null`ï¼Œæ‰€ä»¥è¿™é‡Œä¸æ˜¯æŒ‡é’ˆï¼Œè€Œæ˜¯ `Option`

---

### 2ï¸âƒ£ `Link<T>`

```rust
type Link<T> = Option<Box<Node<T>>>;
```

è¿™æ˜¯ä¸€ä¸ª **ç±»å‹åˆ«å**ã€‚

å®ƒç­‰ä»·äºï¼š

```rust
Option<Box<Node<T>>>
```

å«ä¹‰ï¼š

* `Option`ï¼šå¯èƒ½æœ‰èŠ‚ç‚¹ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰ï¼ˆç©ºé“¾è¡¨ï¼‰
* `Box<Node<T>>`ï¼š

  * `Node` å­˜åœ¨ **å †ä¸Š**
  * `Box` è¡¨ç¤ºâ€œæˆ‘æ‹¥æœ‰è¿™å—å†…å­˜â€

ğŸ“Œ **å…³é”®æŠ€æœ¯ç‚¹**

* `Option` ä»£æ›¿ `NULL`
* `Box` ç”¨æ¥åšé€’å½’ç»“æ„ï¼ˆé“¾è¡¨ã€æ ‘ï¼‰

---

### 3ï¸âƒ£ `Node<T>`

```rust
struct Node<T> {
    elem: T,
    next: Link<T>,
}
```

æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ï¼š

* `elem`ï¼šå½“å‰èŠ‚ç‚¹çš„å€¼
* `next`ï¼šä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆè¿˜æ˜¯ `Option<Box<Node<T>>>`ï¼‰

ğŸ“Œ Rust ä¸å…è®¸ï¼š

```rust
struct Node {
    next: Node // âŒ æ— é™å¤§å°
}
```

æ‰€ä»¥å¿…é¡»ç”¨ `Box`ã€‚

---

## äºŒã€åŸºç¡€æ“ä½œå‡½æ•°

---

## 1ï¸âƒ£ `new()` â€”â€” åˆ›å»ºç©ºé“¾è¡¨

```rust
pub fn new() -> Self {
    List { head: None }
}
```

é€è¡Œè§£é‡Šï¼š

* `pub fn new()`ï¼šå…¬å…±å‡½æ•°
* `-> Self`ï¼šè¿”å› `List<T>`
* `head: None`ï¼šæ²¡æœ‰ä»»ä½•èŠ‚ç‚¹

ğŸ“Œ æŠ€æœ¯ç‚¹ï¼š

* `None` å°±æ˜¯â€œç©ºé“¾è¡¨â€
* Rust ä¸éœ€è¦æ„é€ å‡½æ•°ï¼Œç”¨æ™®é€šå‡½æ•°å³å¯

---

## 2ï¸âƒ£ `push()` â€”â€” å¤´æ’æ³•

```rust
pub fn push(&mut self, elem: T) {
```

* `&mut self`ï¼š**å¯å˜å€Ÿç”¨**

  * è¯´æ˜ï¼šè¿™ä¸ªå‡½æ•°ä¼šä¿®æ”¹é“¾è¡¨

---

```rust
let new_node = Box::new(Node {
    elem,
    next: self.head.take(),
});
```

é€æ­¥æ‹†è§£ï¼š

* `Box::new(...)`

  * åœ¨å †ä¸Šåˆ›å»ºä¸€ä¸ª `Node`
* `elem`

  * æŠŠä¼ è¿›æ¥çš„å€¼æ”¾è¿›å»
* `self.head.take()`

è¿™æ˜¯**éå¸¸é‡è¦çš„ä¸€è¡Œ**ï¼š

* `take()`ï¼š

  * æŠŠ `self.head` çš„å€¼ **æ‹¿èµ°**
  * åŸæ¥çš„ `head` è¢«ç½®ä¸º `None`

å¦‚æœåŸæ¥æ˜¯ï¼š

```text
head -> A -> B -> C
```

ç°åœ¨ï¼š

```text
new_node.next -> A -> B -> C
head -> None
```

ğŸ“Œ æŠ€æœ¯ç‚¹ï¼š

* **æ‰€æœ‰æƒä¸èƒ½å¤åˆ¶**
* `take()` æ˜¯ Rust é‡Œâ€œå®‰å…¨æ¬èµ°å€¼â€çš„æ ‡å‡†åšæ³•

---

```rust
self.head = Some(new_node);
```

* æŠŠæ–°èŠ‚ç‚¹è®¾ä¸ºå¤´èŠ‚ç‚¹

æœ€ç»ˆç»“æ„ï¼š

```text
head -> new_node -> A -> B -> C
```

---

## 3ï¸âƒ£ `pop()` â€”â€” å¤´åˆ æ³•

```rust
pub fn pop(&mut self) -> Option<T> {
```

* å¯èƒ½åˆ é™¤æˆåŠŸï¼Œä¹Ÿå¯èƒ½æ˜¯ç©ºé“¾è¡¨
* æ‰€ä»¥è¿”å› `Option<T>`

---

```rust
self.head.take().map(|node| {
```

è§£é‡Šï¼š

* `self.head.take()`ï¼š

  * æ‹¿èµ° head
* å¦‚æœæ˜¯ `None`ï¼š

  * æ•´ä¸ªå‡½æ•°è¿”å› `None`
* å¦‚æœæ˜¯ `Some(node)`ï¼š

  * è¿›å…¥ `map`

ğŸ“Œ Rust çš„ `map` æ˜¯**å®‰å…¨çš„æ¡ä»¶æ‰§è¡Œ**

---

```rust
self.head = node.next;
```

* æŠŠå¤´èŠ‚ç‚¹çš„ `next` è®¾ä¸ºæ–°çš„ head

---

```rust
node.elem
```

* è¿”å›è¢«åˆ é™¤èŠ‚ç‚¹çš„å€¼
* `node` ç”Ÿå‘½å‘¨æœŸç»“æŸï¼Œ`Box` è‡ªåŠ¨é‡Šæ”¾å†…å­˜

ğŸ“Œ **è¿™é‡Œå®Œå…¨æ²¡æœ‰ free()**

---

## 4ï¸âƒ£ `peek()` â€”â€” çœ‹å¤´å…ƒç´ ï¼ˆåªè¯»ï¼‰

```rust
pub fn peek(&self) -> Option<&T> {
```

* `&self`ï¼šä¸å¯å˜å€Ÿç”¨
* è¿”å› `&T`ï¼š**å¼•ç”¨ï¼Œä¸æ˜¯å€¼**

---

```rust
self.head.as_ref().map(|node| &node.elem)
```

æ‹†è§£ï¼š

* `as_ref()`ï¼š

  * `Option<Box<Node<T>>>`
  * å˜æˆ `Option<&Box<Node<T>>>`
* `map`ï¼š

  * å®‰å…¨è®¿é—®
* `&node.elem`ï¼š

  * è¿”å›å¼•ç”¨ï¼Œä¸è½¬ç§»æ‰€æœ‰æƒ

ğŸ“Œ Rust çš„è§„åˆ™ï¼š

> åªè¯»æ“ä½œ â†’ å€Ÿç”¨
> ä¿®æ”¹ / ç§»åŠ¨ â†’ æ‰€æœ‰æƒ

---

## 5ï¸âƒ£ `peek_mut()` â€”â€” çœ‹å¤´å…ƒç´ ï¼ˆå¯å†™ï¼‰

```rust
pub fn peek_mut(&mut self) -> Option<&mut T> {
```

* è¿”å› `&mut T`
* åŒä¸€æ—¶é—´åªèƒ½æœ‰ **ä¸€ä¸ªå¯å˜å€Ÿç”¨**

---

```rust
self.head.as_mut().map(|node| &mut node.elem)
```

* `as_mut()`ï¼š

  * `Option<Box<Node>>`
  * â†’ `Option<&mut Box<Node>>`

ğŸ“Œ è¿™ä¿è¯ï¼š

* ä¿®æ”¹å…ƒç´ æ—¶ï¼Œé“¾è¡¨ä¸èƒ½è¢«åˆ«äººåŒæ—¶è®¿é—®

---

## ä¸‰ã€ä¸å¯å˜è¿­ä»£å™¨

---

### 1ï¸âƒ£ `Iter` ç»“æ„ä½“

```rust
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}
```

å«ä¹‰ï¼š

* `'a`ï¼šç”Ÿå‘½å‘¨æœŸ
* `next`ï¼šå½“å‰èŠ‚ç‚¹çš„å¼•ç”¨

ğŸ“Œ æŠ€æœ¯ç‚¹ï¼š

* è¿­ä»£å™¨ **ä¸æ‹¥æœ‰èŠ‚ç‚¹**
* åªæ˜¯â€œå€Ÿç”¨é“¾è¡¨â€

---

### 2ï¸âƒ£ `iter()` æ–¹æ³•

```rust
pub fn iter(&self) -> Iter<'_, T> {
```

* `'_`ï¼šç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼ç”Ÿå‘½å‘¨æœŸ

---

```rust
Iter {
    next: self.head.as_deref(),
}
```

* `as_deref()`ï¼š

  * `Option<Box<Node>>`
  * â†’ `Option<&Node>`

ğŸ“Œ å¸¸è§æŠ€å·§ï¼š
**Box â†’ &Node**

---

### 3ï¸âƒ£ `Iterator for Iter`

```rust
fn next(&mut self) -> Option<Self::Item> {
```

* `Iterator` è¦æ±‚å®ç° `next()`

---

```rust
self.next.map(|node| {
```

* å¦‚æœè¿˜æœ‰èŠ‚ç‚¹ï¼Œè¿›å…¥

---

```rust
self.next = node.next.as_deref();
```

* æŠŠæŒ‡é’ˆå¾€åç§»åŠ¨

---

```rust
&node.elem
```

* è¿”å›å½“å‰å…ƒç´ çš„å¼•ç”¨

ğŸ“Œ å®Œå…¨ä¸å¤åˆ¶ã€ä¸åˆ†é…

---

## å››ã€å¯å˜è¿­ä»£å™¨ï¼ˆæ ¸å¿ƒéš¾ç‚¹ï¼‰

---

### 1ï¸âƒ£ `IterMut`

```rust
pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}
```

* å¯å˜å¼•ç”¨
* Rust è¦æ±‚ï¼š**åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ª**

---

### 2ï¸âƒ£ `iter_mut()`

```rust
IterMut {
    next: self.head.as_deref_mut(),
}
```

* `as_deref_mut()`ï¼š

  * `Option<Box<Node>>`
  * â†’ `Option<&mut Node>`

---

### 3ï¸âƒ£ `next()` å®ç°

```rust
self.next.take().map(|node| {
```

âš ï¸ **å¿…é¡»ç”¨ `take()`**

åŸå› ï¼š

* ä¸èƒ½åŒæ—¶ï¼š

  * è¿”å› `&mut node.elem`
  * åˆä¿ç•™ `self.next`

---

```rust
self.next = node.next.as_deref_mut();
```

* ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹

---

```rust
&mut node.elem
```

* è¿”å›å½“å‰å…ƒç´ çš„å¯å˜å¼•ç”¨

ğŸ“Œ è¿™æ˜¯ Rust å€Ÿç”¨è§„åˆ™çš„ç»å…¸æ¡ˆä¾‹

---

## æ€»ç»“ä½ å­¦åˆ°çš„ Rust æ ¸å¿ƒæŠ€æœ¯

ä½ åˆšåˆšå·²ç»æ¥è§¦åˆ°ï¼š

* `Option` ä»£æ›¿ç©ºæŒ‡é’ˆ
* `Box` ç®¡ç†å †å†…å­˜
* æ‰€æœ‰æƒè½¬ç§»ï¼ˆ`take()`ï¼‰
* å€Ÿç”¨è§„åˆ™ï¼ˆ`&` / `&mut`ï¼‰
* ç”Ÿå‘½å‘¨æœŸ
* è¿­ä»£å™¨æ¨¡å‹
* RAII è‡ªåŠ¨é‡Šæ”¾

å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ï¼š

* ç”» **å†…å­˜å›¾ä¸€æ­¥æ­¥æ¼”ç¤º**
* ç”¨ **C é“¾è¡¨å¯¹æ¯” Rust**
* å¸®ä½ æ‰‹å†™ä¸€ç‰ˆâ€œé”™è¯¯å†™æ³•â€ï¼Œçœ‹ç¼–è¯‘å™¨æ€ä¹ˆæ‹¦ä½ 
* æˆ–è®²ä¸ºä»€ä¹ˆ Rust æ ‡å‡†åº“çš„ `LinkedList` å¾ˆå°‘ç”¨
