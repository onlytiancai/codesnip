下面我给你一个**非常基础、适合 Rust 小白**的例子，只用最核心的语法，不用泛型、不用 trait、不用迭代器的高级写法，目的就是让你把 **数组、函数、可变借用、for 循环**这些基础打牢。

我会先给完整代码，然后**逐块解释**。

---

### 一、完整示例代码

```rust
fn main() {
    // 1. 定义一个数组
    let mut arr = [5, 2, 9, 1, 3];

    // 2. 对数组排序
    sort_array(&mut arr);

    // 3. 按顺序打印数组中的每一个元素
    print_array(&arr);
}

// 比较两个 i32 的大小
// 如果 a > b，返回 true
fn greater(a: i32, b: i32) -> bool {
    a > b
}

// 对数组进行排序（简单的冒泡排序）
fn sort_array(arr: &mut [i32]) {
    let len = arr.len();

    for i in 0..len {
        for j in 0..len - 1 - i {
            // 使用比较函数
            if greater(arr[j], arr[j + 1]) {
                // 交换两个元素
                let tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
    }
}

// 打印数组中的每一个元素
fn print_array(arr: &[i32]) {
    for i in 0..arr.len() {
        println!("{}", arr[i]);
    }
}
```

---

### 二、一步一步解释

#### 1️⃣ 定义数组

```rust
let mut arr = [5, 2, 9, 1, 3];
```

要点：

* `[5, 2, 9, 1, 3]` 是 **定长数组**
* 元素类型是 `i32`（编译器自动推导）
* `mut` 非常重要
  因为排序会 **修改数组内容**

---

#### 2️⃣ 比较大小的函数

```rust
fn greater(a: i32, b: i32) -> bool {
    a > b
}
```

解释：

* `fn` 定义函数
* 参数类型必须写清楚
* 返回值是 `bool`
* Rust 中最后一行**没有分号**表示返回值

这个函数的作用很单一：

> 判断第一个数是否比第二个数大

---

#### 3️⃣ 排序函数

```rust
fn sort_array(arr: &mut [i32]) {
```

关键点：

* 参数是 `&mut [i32]`
* 不是 `[i32; 5]`

原因：

* `[i32]` 是 **切片**
* 可以接收任何长度的数组
* `&mut` 说明：函数里要改数组

---

```rust
let len = arr.len();
```

* `.len()` 获取数组长度

---

```rust
for i in 0..len {
    for j in 0..len - 1 - i {
```

* 双重循环
* 这是 **冒泡排序**
* 每一轮把最大的数“冒”到后面

---

```rust
if greater(arr[j], arr[j + 1]) {
```

* 调用我们自己写的比较函数
* 不直接写 `>`，而是**练习函数调用**

---

```rust
let tmp = arr[j];
arr[j] = arr[j + 1];
arr[j + 1] = tmp;
```

* 手动交换两个元素
* 和 C 写法非常像
* Rust 不允许越界，编译期 + 运行期都会检查

---

#### 4️⃣ 打印数组

```rust
fn print_array(arr: &[i32]) {
```

* 只读即可，所以用 `&[i32]`
* 这是 Rust 推荐的写法

---

```rust
for i in 0..arr.len() {
    println!("{}", arr[i]);
}
```

* 用下标访问
* 每个元素单独打印一行

---

### 三、程序运行结果

输出：

```
1
2
3
5
9
```

---

### 四、你在这个例子里学到的 Rust 基础

这个小程序已经覆盖了很多关键点：

* 数组 `[T; N]`
* 切片 `&[T]` / `&mut [T]`
* 可变借用
* 函数参数与返回值
* for 循环 + 范围
* 下标访问（安全）
* 手写排序算法

如果你愿意，下一步我可以：

* 把它改成 **泛型排序**
* 用 **闭包代替比较函数**
* 对比 Rust 自带的 `sort()`
* 解释为什么 Rust 强烈推荐“切片参数”
